# <Project#3 : OOP for Billiard Game>
@DirectX 3D로 구현한 당구 게임입니다.

@팀프로젝트로, report 내용과 유사합니다.

#
 	1. 설계 방향

 편의성과 현실성있는 부분에 디테일을 강조한 당구 게임을 만드는데 가장 큰 의의를 두었다.
 시각적으로 보기 편한 파란공(겨냥공)을 두어서 공의 두께조절이 용이하게했고 360도 시점이동을 통해 공 배치를 여러 각도에서 보게했다. 또 TAB을 누르면 기본시점으로 이동하는 편의성을 추가하였다. 공의 당점을 좌표로 받고(mesh_x,mesh_y) 키보드 화살표를 통해 상하좌우 회전조절을 용이하게하고 space 버튼을 두 번 누르는 방식을 채택하여 힘 조절을 용이하게 구현하였다. 이로 인하여 파란 공과 수구와의 거리가 중요한 요소가 아니므로 두께 조절을 하기 더 쉬워졌다.

이처럼 플레이하기 쉽고 현실과 가깝게 개발하는 쪽으로 설계 방향을 잡았다. 

#
	2. 클래스

1) Csphere
 

-setIndex : 몇 번째 공인지 설정해 준다.
-hasintersected : 공과 공 사이의 거리가 공의 반지름의 2배보다 작으면 충돌로 인식한다. 여기서 1.9999999f로 설정한 이유는 공끼리 부딪히지도 않았는데 충돌로 인식할 수 있기 때문에 설정해주었다. 이 때문에 공이 겹치는 경우가 생기는데 이는 hitby 함수에서 해결해준다.
-hitby : 위 그림에서 보이는 겹치는 부분의 절반이 gap인데 그 gap만큼 양 쪽 공이 멀어지는 방향으로 벌려주면 두 공사이의 거리가 정확히 반지름의 2배가 된다. 이걸로 겹치는 문제가 해결되고 2번 충돌하지 않는다. 
-ballupdate : 파란공(겨냥공)이 밖으로 못벗어나게 하며 시간이 지날수록 공의 속도와 토크가 점점 줄어든다. 
-getTork : 토크(돌림힘) 반환
-setTork : 객체가 얼마나 토크를 가지고 있는지 mesh_x, mesh_y 변수를 받아서 일정값(ALPHA)을 연산해줌
-updateTork : tork가 점점 줄어들기 때문에 이걸 반영시키기 위한 함수




2) CWall
- rotate : 공이 벽에 충돌했을 때 원래 가려던 벡터를 회전량에 비례해서 진행할 수 있게 해준다. 
- hasintersected : 공의 중심좌표와 벽의 x 혹은 z 거리가 (공 반지름 + 0.06f)보다 작으면 충돌로 인식한다. 
- setIndex : 공이 어느 벽에 맞았는지 공 객체가 알 수 있게 도와주는 함수
- hitby : hasintersected가 참일 때 실행되며 위 그림처럼 gap만큼 공을 떨어뜨린다. 가로벽이면 z 속도벡터를 부호변환하고 세로벽이면 x 속도벡터를 부호변환한다. getTork가 있으면 4가지 경우에 따라 충돌 직후에 갈 속도 벡터를 rotate 함수를 이용해서 회전시켜준다. 





3) CLight

-> 기존 제공된 클래스와 비슷하다.


4) CPlayer
- getscore : 득점
- losescore :실점     -> 1인모드에서는 득점/실점 반대
- set_first_player : 어느 플레이어의 차례인지 초기 설정
- turn : 플레이어의 차례를 바꿈 




5) Sound
-DirectSound를 사용하기 위해 dsound.lib과 같은 라이브러리 참조
-인트로 사운드, 부딪히는 효과음을 Sound 형식의 객체 intro, ddack로 전역변수로 선언
-CreateDirectSound : directsound 버퍼 생성
-LoadWave : .wav 파일명을 문자열로 입력받아 읽음
-Play : 버퍼에 저장된 파일 재생, 메소드등을 활용하여 각 상황에 맞는 소리 재생



6) font
-Init : 어느 디바이스에 글자를 쓸 것인가를 결정, 높이 길이 설정
-Print : DrawTextA 호출 / 좌표, 색깔 설정
-GetInst : 메모리 할당
-freeInst : 메모리 해제




#
	3. 특징

1) 메인 메뉴 / 엔딩

2) 점수판
1인모드에서는 플레이어1의 점수만, 2인모드에서는 플레이어 1, 2의 점수만 나타나게 했다. 1인모드의 경우 0점에서 시작해 한번 성공 시 10점씩 증가, 한번 실패 시 10점씩 감소하는 방식이며 2인모드에서는 초기 점수 150점으로 설정해 한번 성공 시 10점씩 감소하며 한번 더 칠 기회를 갖는다. 한번 실패 시 10점씩 증가하며 차례가 바뀌며 0점이 되어야 게임이 종결된다. 

3) 시점 초기화 
공의 배치를 시점을 이동하며 여러 각도에서 확인하고 난 뒤 기본시점이아닌 다른 시점일때는 파란공(겨냥공)이 이상하게 이동하기 때문에 VK_TAB을 인식하면 디바이스에 위 사진처럼 기본 시점으로 되돌리는 기능을 구현하였다. 


4) 공 두께조절, 파워조절 
기존에 제공된 코드는 수구와 파란공(겨냥공) 사이의 거리에 비례해 힘을 조절하는 방식으로 구현했었다. 하지만 이 방식대로 하면 수구와 1적구의 정확한 두께 판단이 힘들어 게임을 진행하는데에 불편함이 있었다. 그래서 힘 조절을 space키를 한번 누르면 위 사진처럼 게임 우측상단에 ‘파워 = 0~100’ 를 반복하게 만들었고 원하는 힘에서 space를 한번 더 누르면 그 파워로 공이 진행하게 구현하였다. 이로써 파워 조절을 용이하게 하였다. 1적구에 파란공(겨냥공)을 겹쳐 둠으로써 좀 더 정확한 두께 판단이 가능해졌다. 또 파란공(겨냥공)이 당구대 밖에 못나가게 하여 게임을 진행하는데 불편함을 줄였다. 


 5) 공의 회전

	1) 오른쪽 / 왼쪽 회전

입력값으로 mesh_x가 들어오면 거기다 일정한 상수 알파를 곱해서 그값(tork_x)을 -30~30(%)의 범위를 갖게 만들어준다.
토크값을 위와 같이 정한 이유는 퍼센트로 하지않고 항상 회전량을 고려하여 일정하게 속도벡터를 돌려주게 되면 입사각이 속도벡터를 회전시킬 각 theta보다 작으면 충돌후 공의 속도벡터가 벽쪽을 향하게 되기때문에 벽에 붙어서 진행하게된다. 따라서 입사각의 최대 30퍼센트만큼 회전시켜주어 다음과 같은 오류를 피할수 있게 하였다.
회전을 가진 공이 벽에 충돌하면 그공의 진행 방향과 토크값을 고려하여 속도벡터가 충돌후 어느 방향으로 진행할지를 생각하여 그 방향으로 rotate함수를 이용하여 돌려준다. 토크 값이 음수일경우 공의 진행 방향에 상관없이 항상 충돌 후 속도 벡터의 진행 방향이 반시계 방향으로 회전되어야 하고 토크값이 양수일 경우 충돌 후의 진행 방향이 시계방향으로 회전되어야 한다. rotate함수는 theta만큼 반시계 방향으로 돌려주기 때문에 토크가 음수일 경우 2파이 - theta 를 넣은 것과 같기 때문에 theta 만큼 시계방향으로 돌려줄수 있게 된다. 실제 게임에서는 왼쪽/오른쪽 방향키로 왼쪽/오른쪽 당점을 조절할 수 있다. 


	2) 밀어치기 / 끌어치기

- 보다 현실감있는 당구 게임을 위해 일정 두께 이상을 쳤을 때 당점이 위 / 아래면 밀어치기 / 끌어치기가 되도록 구현하였다. 수구가 1적구를 맞기 전 벡터(vec_this), 수구가 1적구를 맞고난 후의 벡터(vec_this_after)라 하면 일정 두께 이상을 맞았는지 알기 위해서 우선 vec_this와 vec_this_after를 크기가 1인 기저벡터로 바꾼 후 vec_this와 vec_this_after를 내적한 값이 일정 크기 이상이면 밀어치기 / 끌어치기가 구현되도록 하였다. 수많은 수행착오 끝에 일정 크기를 0.5로 결정했다. 
- 밀어치기와 끌어치기의 방향과 힘은 vec_this와 vec_this_after 각 벡터를 x,y축 속도로 분해한 후 각각을 더해서 합성시킴으로써 방향과 힘을 결정했다. 여기서 끌어치기는 tork_y의 값이 음수이  때문에 vec_this에 -를 곱해서 연산해줘야 한다. 실제 게임에서는 위/아래 방향키로 위/아래 당점을 조절할 수 있다. 




#
	4. 보완할 점

1. 당구 게임을 기본 시점을 기준으로 했기 때문에 기본시점이 아닌 다른 시점일 때는 파란공(겨냥공)을 우클릭으로 이동하려하면 이상하게 이동한다. 

2. 공과 벽의 마찰력이 없어서 현실과는 다르게 공끼리 충돌해도 에너지가 완벽하게 보존된다. 
